User: Sistemime `Keycloak` kullanarak merkezi IAM kurmak istiyorum. 
Bu sessionda bir senior developer ve eÄŸitmen rollerini bÃ¼rÃ¼nerek bana Keycloak entegrasyonunu nasÄ±l yapacaÄŸÄ±mÄ± anlat.
Projemdeki hangi kÄ±sÄ±mlarda nelere ihtiyacÄ±m var bunun raporunu oluÅŸtur.
Keycloak admin panelinde yapacaÄŸÄ±m her ÅŸeyi net adÄ±mlar olarak Ã§Ä±kart.

Ã‡IKTI FORMATINDA:
OluÅŸturulan tÃ¼m raporlarÄ± ve anlatÄ±mlarÄ± ayrÄ± baÅŸlÄ±klarda net ve temiz olarak ver.

SINIRLAR:
Keycloak: 26.5.1 versiyonu kullanÄ±lmalÄ±.
Realm ismi: ecommerce olmalÄ±.

GitHub Copilot: Ã–nce projenizin mevcut durumunu inceleyerek kapsamlÄ± bir Keycloak entegrasyon raporu hazÄ±rlayacaÄŸÄ±m. 

Read [](file:///c%3A/Users/PC1/Desktop/Projects/Education/Java/turkcell-ai-2/gateway-service/src/main/resources/application.yml)

Read [](file:///c%3A/Users/PC1/Desktop/Projects/Education/Java/turkcell-ai-2/order-service/pom.xml#1-1), lines 1 to 100

Read [](file:///c%3A/Users/PC1/Desktop/Projects/Education/Java/turkcell-ai-2/inventory-service/pom.xml#1-1), lines 1 to 100

Read [](file:///c%3A/Users/PC1/Desktop/Projects/Education/Java/turkcell-ai-2/gateway-service/pom.xml)

Searched for files matching `**/java/com/ecommerce/**/*.java`, 50 matches

Read [](file:///c%3A/Users/PC1/Desktop/Projects/Education/Java/turkcell-ai-2/docs/openapi/order-service.yaml#1-1), lines 1 to 50

Åimdi daha detaylÄ± inceleme yapayÄ±m: 

Searched for text `@RestController`, 6 results

Searched for text `@GetMapping`, 6 results

Searched for text `@PostMapping`, 7 results

MÃ¼kemmel! Åimdi kapsamlÄ± Keycloak entegrasyon raporunu hazÄ±rlÄ±yorum.

---

# ğŸ” KEYCLOAK 26.5.1 ENTEGRASYONu - SENIOR DEVELOPER REHBERÄ°

---

## ğŸ“‹ Ä°Ã‡Ä°NDEKÄ°LER

1. **MÄ°MARÄ° GENEL BAKIÅ**
2. **KEYCLOAK KURULUMU VE YAPILANDIRMASI**
3. **KEYCLOAK ADMÄ°N PANEL ADIMLARI**
4. **PROJE ENTEGRASYON RAPORU**
5. **TEKNÄ°K UYGULAMA DETAYLARI**
6. **TEST SENARYOLARI**

---

## 1ï¸âƒ£ MÄ°MARÄ° GENEL BAKIÅ

### 1.1 Neden Keycloak?

Keycloak, mikroservis mimarinizde **merkezi kimlik doÄŸrulama ve yetkilendirme** saÄŸlar:

- âœ… **Single Sign-On (SSO)**: KullanÄ±cÄ± bir kez giriÅŸ yapar, tÃ¼m servislere eriÅŸir
- âœ… **OAuth2 & OpenID Connect**: Modern gÃ¼venlik standartlarÄ±
- âœ… **Role-Based Access Control (RBAC)**: Rol bazlÄ± yetkilendirme
- âœ… **Token-Based Security**: JWT token'lar ile stateless gÃ¼venlik
- âœ… **Sosyal Medya Entegrasyonu**: Google, Facebook, GitHub ile giriÅŸ

### 1.2 Mevcut Mimarinizde Keycloak'Ä±n Yeri

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   CLIENT    â”‚ (Web/Mobile App)
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚ 1. Login Request
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   KEYCLOAK SERVER       â”‚ â—„â”€â”€â”€ Realm: ecommerce
â”‚   Port: 8180            â”‚      - Users
â”‚                         â”‚      - Roles
â”‚   â€¢ Authentication      â”‚      - Clients
â”‚   â€¢ Token Generation    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ 2. JWT Token
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   GATEWAY SERVICE       â”‚ â—„â”€â”€â”€ Token Validation
â”‚   Port: 8080            â”‚      JWT Decoder
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ 3. Forwarded Request (with token)
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  BACKEND SERVICES       â”‚
â”‚  â€¢ order-service:8081   â”‚ â—„â”€â”€â”€ Resource Server
â”‚  â€¢ inventory:8082       â”‚      Method Security
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.3 GÃ¼venlik AkÄ±ÅŸÄ± (OAuth2 Authorization Code Flow)

```
1. User â†’ Gateway â†’ Keycloak Login Page
2. User enters credentials
3. Keycloak â†’ Returns Authorization Code
4. Gateway exchanges code â†’ Access Token (JWT)
5. Gateway â†’ Backend (with Bearer Token)
6. Backend validates token â†’ Extracts roles â†’ Executes business logic
```

---

## 2ï¸âƒ£ KEYCLOAK KURULUMU VE YAPILANDIRMASI

### 2.1 Docker ile Keycloak 26.5.1 Kurulumu

Proje kÃ¶k dizininizde `docker-compose.yml` oluÅŸturun:

```yaml
version: '3.8'

services:
  keycloak:
    image: quay.io/keycloak/keycloak:26.5.1
    container_name: ecommerce-keycloak
    environment:
      KEYCLOAK_ADMIN: admin
      KEYCLOAK_ADMIN_PASSWORD: admin
      KC_DB: postgres
      KC_DB_URL: jdbc:postgresql://keycloak-postgres:5432/keycloak
      KC_DB_USERNAME: keycloak
      KC_DB_PASSWORD: keycloak
      KC_HOSTNAME: localhost
      KC_HTTP_PORT: 8180
    ports:
      - "8180:8180"
    command:
      - start-dev
      - --http-port=8180
    depends_on:
      - keycloak-postgres
    networks:
      - ecommerce-network

  keycloak-postgres:
    image: postgres:16-alpine
    container_name: keycloak-postgres
    environment:
      POSTGRES_DB: keycloak
      POSTGRES_USER: keycloak
      POSTGRES_PASSWORD: keycloak
    volumes:
      - keycloak-postgres-data:/var/lib/postgresql/data
    networks:
      - ecommerce-network

  # Kafka (mevcut messaging iÃ§in)
  zookeeper:
    image: confluentinc/cp-zookeeper:7.5.0
    container_name: zookeeper
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000
    networks:
      - ecommerce-network

  kafka:
    image: confluentinc/cp-kafka:7.5.0
    container_name: kafka
    depends_on:
      - zookeeper
    ports:
      - "29023:29023"
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://localhost:29023
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
    networks:
      - ecommerce-network

volumes:
  keycloak-postgres-data:

networks:
  ecommerce-network:
    driver: bridge
```

**BaÅŸlatma komutu:**
```bash
docker-compose up -d
```

**Keycloak Admin Console:**
- URL: http://localhost:8180
- Username: `admin`
- Password: `admin`

---

## 3ï¸âƒ£ KEYCLOAK ADMÄ°N PANEL ADIMLARI (ADIM ADIM)

### ğŸ“Œ ADIM 1: Realm OluÅŸturma

1. **Admin Console'a giriÅŸ yapÄ±n**: http://localhost:8180
2. Sol Ã¼st kÃ¶ÅŸede **"master"** dropdown'Ä±na tÄ±klayÄ±n
3. **"Create Realm"** butonuna tÄ±klayÄ±n
4. Realm bilgilerini girin:
   - **Realm name**: `ecommerce`
   - **Enabled**: `ON`
5. **Create** butonuna tÄ±klayÄ±n

âœ… **SonuÃ§**: `ecommerce` realm'i oluÅŸturuldu.

---

### ğŸ“Œ ADIM 2: Client TanÄ±mlamalarÄ±

#### 2.1 Gateway Client (Frontend iÃ§in)

1. Sol menÃ¼den **"Clients"** â†’ **"Create client"**
2. **General Settings**:
   - **Client type**: `OpenID Connect`
   - **Client ID**: `gateway-client`
   - **Name**: `Gateway Service Client`
   - **Next**
3. **Capability config**:
   - **Client authentication**: `ON`
   - **Authorization**: `OFF`
   - **Standard flow**: `ON` âœ“
   - **Direct access grants**: `ON` âœ“
   - **Next**
4. **Login settings**:
   - **Root URL**: `http://localhost:8080`
   - **Valid redirect URIs**: 
     - `http://localhost:8080/*`
     - `http://localhost:8080/login/oauth2/code/*`
   - **Valid post logout redirect URIs**: `http://localhost:8080/*`
   - **Web origins**: `http://localhost:8080`
   - **Save**

5. **Credentials Tab**'a gidin:
   - **Client Secret** deÄŸerini kopyalayÄ±n (Ã¶rn: `abc123xyz...`)
   - Bu deÄŸeri not edin, Spring Config'de kullanacaksÄ±nÄ±z

---

#### 2.2 Order Service Client

1. **"Clients"** â†’ **"Create client"**
2. **Client ID**: order-service
3. **Client authentication**: `ON`
4. **Service accounts roles**: `ON` âœ“
5. **Valid redirect URIs**: `http://localhost:8081/*`
6. **Save**
7. **Credentials** tab'dan secret'Ä± not edin

---

#### 2.3 Inventory Service Client

1. **"Clients"** â†’ **"Create client"**
2. **Client ID**: inventory-service
3. **Client authentication**: `ON`
4. **Service accounts roles**: `ON` âœ“
5. **Valid redirect URIs**: `http://localhost:8082/*`
6. **Save**
7. **Credentials** tab'dan secret'Ä± not edin

---

### ğŸ“Œ ADIM 3: Realm Roller (Roles) TanÄ±mlama

1. Sol menÃ¼den **"Realm roles"** â†’ **"Create role"**

**AÅŸaÄŸÄ±daki rolleri tek tek oluÅŸturun:**

| Role Name           | Description                                      |
|---------------------|--------------------------------------------------|
| `ROLE_CUSTOMER`     | Normal mÃ¼ÅŸteri - sipariÅŸ oluÅŸturabilir          |
| `ROLE_ADMIN`        | YÃ¶netici - tÃ¼m iÅŸlemleri yapabilir              |
| `ROLE_INVENTORY_MANAGER` | Stok yÃ¶neticisi - inventory okuma/yazma  |
| `ROLE_ORDER_MANAGER`     | SipariÅŸ yÃ¶neticisi - sipariÅŸleri yÃ¶netir |

Her rol iÃ§in:
- **Role name**: YukarÄ±daki ismi girin
- **Description**: AÃ§Ä±klama girin
- **Save**

---

### ğŸ“Œ ADIM 4: KullanÄ±cÄ± OluÅŸturma

#### 4.1 Admin KullanÄ±cÄ±sÄ±

1. Sol menÃ¼den **"Users"** â†’ **"Create new user"**
2. **User bilgileri**:
   - **Username**: `admin`
   - **Email**: `admin@ecommerce.com`
   - **Email verified**: `ON`
   - **First name**: `Admin`
   - **Last name**: `User`
   - **Create**
3. **Credentials** tab:
   - **Set password**: `admin123`
   - **Temporary**: `OFF` (kalÄ±cÄ± ÅŸifre)
   - **Save**
4. **Role mapping** tab:
   - **Assign role** â†’ `ROLE_ADMIN` seÃ§in
   - **Assign**

---

#### 4.2 Normal MÃ¼ÅŸteri

1. **"Users"** â†’ **"Create new user"**
2. **User bilgileri**:
   - **Username**: `customer1`
   - **Email**: `customer1@test.com`
   - **Email verified**: `ON`
   - **First name**: `John`
   - **Last name**: `Doe`
   - **Create**
3. **Credentials** tab:
   - **Set password**: `customer123`
   - **Temporary**: `OFF`
   - **Save**
4. **Role mapping** tab:
   - **Assign role** â†’ `ROLE_CUSTOMER`
   - **Assign**

---

#### 4.3 Inventory Manager

1. **"Users"** â†’ **"Create new user"**
2. **Username**: `inventory_manager`
3. **Email**: `inventory@ecommerce.com`
4. **Credentials**: `inventory123`
5. **Role mapping**: `ROLE_INVENTORY_MANAGER`

---

### ğŸ“Œ ADIM 5: Client Scopes YapÄ±landÄ±rmasÄ± (Ä°steÄŸe BaÄŸlÄ±)

1. Sol menÃ¼den **"Client scopes"** â†’ **"Create client scope"**
2. **Name**: `ecommerce-scope`
3. **Type**: `Default`
4. **Save**

---

### ğŸ“Œ ADIM 6: Token AyarlarÄ±

1. **"Realm settings"** â†’ **"Tokens"** tab
2. AÅŸaÄŸÄ±daki deÄŸerleri ayarlayÄ±n:
   - **Access Token Lifespan**: `15 minutes`
   - **Refresh Token Lifespan**: `30 minutes`
   - **SSO Session Idle**: `30 minutes`
   - **SSO Session Max**: `10 hours`
3. **Save**

---

### ğŸ“Œ ADIM 7: Test (Keycloak Token Endpoint)

Postman veya terminal ile test:

```bash
curl -X POST 'http://localhost:8180/realms/ecommerce/protocol/openid-connect/token' \
-H 'Content-Type: application/x-www-form-urlencoded' \
-d 'grant_type=password' \
-d 'client_id=gateway-client' \
-d 'client_secret=<CLIENT_SECRET>' \
-d 'username=customer1' \
-d 'password=customer123'
```

âœ… **Beklenen YanÄ±t**: JSON ile `access_token`, `refresh_token` dÃ¶ner.

---

## 4ï¸âƒ£ PROJE ENTEGRASYON RAPORU

### 4.1 DeÄŸiÅŸtirilecek/Eklenecek Dosyalar

| Servis | Dosya | Ä°ÅŸlem | AÃ§Ä±klama |
|--------|-------|-------|----------|
| **gateway-service** | pom.xml | GÃ¼ncelle | Spring Security OAuth2 Client ekle |
| | application.yml | GÃ¼ncelle | Keycloak issuer-uri yapÄ±landÄ±rmasÄ± |
| | `SecurityConfig.java` | Yeni | JWT token validation filter |
| | `GatewayFilter.java` | Yeni | Token'Ä± downstream servislere ilet |
| **order-service** | pom.xml | GÃ¼ncelle | Spring Security Resource Server ekle |
| | application.yml | GÃ¼ncelle | JWT issuer-uri |
| | `SecurityConfig.java` | Yeni | Method-level security |
| | OrderController.java | GÃ¼ncelle | @PreAuthorize annotations |
| **inventory-service** | pom.xml | GÃ¼ncelle | Spring Security Resource Server ekle |
| | application.yml | GÃ¼ncelle | JWT issuer-uri |
| | `SecurityConfig.java` | Yeni | Method-level security |
| | InventoryController.java | GÃ¼ncelle | @PreAuthorize annotations |

---

### 4.2 BaÄŸÄ±mlÄ±lÄ±klar (Dependencies)

#### Gateway Service (pom.xml'e eklenecek)
```xml
<!-- Spring Security OAuth2 Client -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-client</artifactId>
</dependency>

<!-- Spring Security OAuth2 Resource Server (JWT) -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
</dependency>

<!-- Spring Security for WebFlux (Gateway reactive) -->
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-oauth2-jose</artifactId>
</dependency>
```

#### Order & Inventory Services (pom.xml'e eklenecek)
```xml
<!-- Spring Security -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

<!-- OAuth2 Resource Server (JWT) -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
</dependency>
```

---

### 4.3 Gateway Service YapÄ±landÄ±rmasÄ±

#### application.yml (gateway-service)
```yaml
server:
  port: 8080

spring:
  application:
    name: gateway-service
  
  security:
    oauth2:
      client:
        provider:
          keycloak:
            issuer-uri: http://localhost:8180/realms/ecommerce
            user-name-attribute: preferred_username
        registration:
          keycloak:
            client-id: gateway-client
            client-secret: <BURAYA_CLIENT_SECRET_GÄ°RÄ°N>
            scope:
              - openid
              - profile
              - email
            authorization-grant-type: authorization_code
            redirect-uri: "{baseUrl}/login/oauth2/code/{registrationId}"
      
      resourceserver:
        jwt:
          issuer-uri: http://localhost:8180/realms/ecommerce
          jwk-set-uri: http://localhost:8180/realms/ecommerce/protocol/openid-connect/certs

  cloud:
    gateway:
      routes:
        - id: order-service
          uri: http://localhost:8081
          predicates:
            - Path=/api/v1/orders/**
          filters:
            - TokenRelay=
            
        - id: inventory-items
          uri: http://localhost:8082
          predicates:
            - Path=/api/v1/inventory/**
          filters:
            - TokenRelay=
            
        - id: reservations
          uri: http://localhost:8082
          predicates:
            - Path=/api/v1/reservations/**
          filters:
            - TokenRelay=
      
      default-filters:
        - DedupeResponseHeader=Access-Control-Allow-Credentials Access-Control-Allow-Origin

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,gateway
```

---

#### `SecurityConfig.java` (gateway-service)

```java
package com.ecommerce.gateway.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.web.server.SecurityWebFilterChain;

@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        http
            .csrf(csrf -> csrf.disable())
            .authorizeExchange(exchanges -> exchanges
                .pathMatchers("/actuator/**", "/login/**", "/oauth2/**").permitAll()
                .pathMatchers("/api/v1/orders/**").hasAnyAuthority("ROLE_CUSTOMER", "ROLE_ADMIN", "ROLE_ORDER_MANAGER")
                .pathMatchers("/api/v1/inventory/**").hasAnyAuthority("ROLE_INVENTORY_MANAGER", "ROLE_ADMIN")
                .pathMatchers("/api/v1/reservations/**").authenticated()
                .anyExchange().authenticated()
            )
            .oauth2Login(oauth2 -> oauth2.loginPage("/oauth2/authorization/keycloak"))
            .oauth2ResourceServer(oauth2 -> oauth2.jwt());
        
        return http.build();
    }
}
```

---

### 4.4 Order Service YapÄ±landÄ±rmasÄ±

#### application.yml (order-service)
```yaml
spring:
  application:
    name: order-service
  
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://localhost:8180/realms/ecommerce
          jwk-set-uri: http://localhost:8180/realms/ecommerce/protocol/openid-connect/certs

# ... (mevcut config korunur)
```

#### `SecurityConfig.java` (order-service)

```java
package com.ecommerce.orderservice.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter;
import org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/actuator/**").permitAll()
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(jwt -> jwt.jwtAuthenticationConverter(jwtAuthenticationConverter()))
            );
        
        return http.build();
    }

    @Bean
    public JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
        grantedAuthoritiesConverter.setAuthorityPrefix("");
        grantedAuthoritiesConverter.setAuthoritiesClaimName("realm_access.roles");

        JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
        jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter);
        
        return jwtAuthenticationConverter;
    }
}
```

#### OrderController.java (GÃ¼ncelleme)

```java
package com.ecommerce.orderservice.web.controller;

import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
// ... diÄŸer importlar

@RestController
@RequestMapping("/api/v1/orders")
public class OrderController {

    // ... mevcut fieldlar

    @PostMapping
    @PreAuthorize("hasAnyAuthority('ROLE_CUSTOMER', 'ROLE_ADMIN', 'ROLE_ORDER_MANAGER')")
    public ResponseEntity<OrderResponseDto> createOrder(
            @Valid @RequestBody OrderRequestDto request,
            @AuthenticationPrincipal Jwt jwt) {
        
        String userId = jwt.getSubject(); // Keycloak user ID
        String username = jwt.getClaimAsString("preferred_username");
        
        // Business logic...
        OrderResponseDto response = orderService.createOrder(request, userId);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasAnyAuthority('ROLE_CUSTOMER', 'ROLE_ADMIN', 'ROLE_ORDER_MANAGER')")
    public ResponseEntity<OrderResponseDto> getOrder(
            @PathVariable UUID id,
            @AuthenticationPrincipal Jwt jwt) {
        
        // Admin tÃ¼m sipariÅŸleri gÃ¶rebilir
        // Customer sadece kendi sipariÅŸlerini
        String userId = jwt.getSubject();
        boolean isAdmin = jwt.getClaimAsStringList("realm_access.roles").contains("ROLE_ADMIN");
        
        OrderResponseDto response = orderService.getOrder(id, userId, isAdmin);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/{id}/cancel")
    @PreAuthorize("hasAnyAuthority('ROLE_CUSTOMER', 'ROLE_ADMIN', 'ROLE_ORDER_MANAGER')")
    public ResponseEntity<CancelOrderResponseDto> cancelOrder(
            @PathVariable UUID id,
            @AuthenticationPrincipal Jwt jwt) {
        
        String userId = jwt.getSubject();
        CancelOrderResponseDto response = orderService.cancelOrder(id, userId);
        return ResponseEntity.ok(response);
    }

    @PatchMapping("/{id}/status")
    @PreAuthorize("hasAnyAuthority('ROLE_ADMIN', 'ROLE_ORDER_MANAGER')")
    public ResponseEntity<OrderResponseDto> updateOrderStatus(
            @PathVariable UUID id,
            @Valid @RequestBody UpdateStatusRequestDto request,
            @AuthenticationPrincipal Jwt jwt) {
        
        OrderResponseDto response = orderService.updateStatus(id, request);
        return ResponseEntity.ok(response);
    }
}
```

---

### 4.5 Inventory Service YapÄ±landÄ±rmasÄ±

#### application.yml (inventory-service)
```yaml
spring:
  application:
    name: inventory-service
  
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: http://localhost:8180/realms/ecommerce
          jwk-set-uri: http://localhost:8180/realms/ecommerce/protocol/openid-connect/certs

# ... (mevcut config korunur)
```

#### `SecurityConfig.java` (inventory-service)
```java
// Order service ile aynÄ± SecurityConfig kullanÄ±lÄ±r
```

#### InventoryController.java (GÃ¼ncelleme)

```java
package com.ecommerce.inventoryservice.web.controller;

import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
// ... diÄŸer importlar

@RestController
@RequestMapping("/api/v1")
public class InventoryController {

    // ... mevcut fieldlar

    @GetMapping("/inventory/items/{productId}")
    @PreAuthorize("hasAnyAuthority('ROLE_INVENTORY_MANAGER', 'ROLE_ADMIN')")
    public ResponseEntity<InventoryItemResponse> getInventoryItem(
            @PathVariable UUID productId,
            @AuthenticationPrincipal Jwt jwt) {
        
        InventoryItemResponse response = getInventoryItemUseCase.execute(productId);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/inventory/check-availability")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<AvailabilityCheckResponse> checkAvailability(
            @Valid @RequestBody AvailabilityCheckRequest request,
            @AuthenticationPrincipal Jwt jwt) {
        
        AvailabilityCheckResponse response = checkAvailabilityUseCase.execute(request);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/reservations")
    @PreAuthorize("hasAnyAuthority('ROLE_CUSTOMER', 'ROLE_ADMIN', 'ROLE_ORDER_MANAGER')")
    public ResponseEntity<StockReservationResponse> createReservation(
            @Valid @RequestBody StockReservationRequest request,
            @AuthenticationPrincipal Jwt jwt) {
        
        String userId = jwt.getSubject();
        StockReservationResponse response = reserveStockUseCase.execute(request, userId);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @GetMapping("/reservations/{reservationId}")
    @PreAuthorize("hasAnyAuthority('ROLE_INVENTORY_MANAGER', 'ROLE_ADMIN', 'ROLE_ORDER_MANAGER')")
    public ResponseEntity<StockReservationResponse> getReservation(
            @PathVariable UUID reservationId,
            @AuthenticationPrincipal Jwt jwt) {
        
        StockReservationResponse response = getReservationUseCase.execute(reservationId);
        return ResponseEntity.ok(response);
    }
}
```

---

## 5ï¸âƒ£ TEKNÄ°K UYGULAMA DETAYLARI

### 5.1 JWT Token Anatomisi

Keycloak'tan dÃ¶nen JWT token iÃ§eriÄŸi:

```json
{
  "exp": 1705926123,
  "iat": 1705925223,
  "jti": "abc-123-xyz",
  "iss": "http://localhost:8180/realms/ecommerce",
  "sub": "user-uuid-here",
  "typ": "Bearer",
  "azp": "gateway-client",
  "session_state": "session-id",
  "realm_access": {
    "roles": [
      "ROLE_CUSTOMER",
      "offline_access"
    ]
  },
  "scope": "openid profile email",
  "email_verified": true,
  "name": "John Doe",
  "preferred_username": "customer1",
  "given_name": "John",
  "family_name": "Doe",
  "email": "customer1@test.com"
}
```

**Ã–nemli Claims:**
- `sub`: KullanÄ±cÄ± ID (UUID)
- `preferred_username`: Username
- `realm_access.roles`: KullanÄ±cÄ±nÄ±n rolleri
- `email`: Email adresi
- `exp`: Token'Ä±n geÃ§erlilik sÃ¼resi

---

### 5.2 Token Propagation (Gateway â†’ Backend)

Gateway'de `TokenRelay=` filter'Ä± otomatik olarak:
1. Ä°stek header'Ä±ndan `Authorization: Bearer <token>` alÄ±r
2. Downstream servislere aynÄ± token'Ä± iletir
3. Backend servisler token'Ä± valide eder

---

### 5.3 Role-Based Access Control (RBAC) Matrisi

| Endpoint | ROLE_CUSTOMER | ROLE_ADMIN | ROLE_ORDER_MANAGER | ROLE_INVENTORY_MANAGER |
|----------|---------------|------------|-------------------|------------------------|
| POST /orders | âœ“ | âœ“ | âœ“ | âœ— |
| GET /orders/{id} | âœ“ (sadece kendi) | âœ“ | âœ“ | âœ— |
| PATCH /orders/{id}/status | âœ— | âœ“ | âœ“ | âœ— |
| GET /inventory/items | âœ— | âœ“ | âœ— | âœ“ |
| POST /inventory/check | âœ“ | âœ“ | âœ“ | âœ“ |
| POST /reservations | âœ“ | âœ“ | âœ“ | âœ— |

---

### 5.4 Service-to-Service Communication (M2M)

Event consumer'lar iÃ§in **Service Account** kullanÄ±lÄ±r:

```java
@Component
public class OrderEventConsumer {

    @Bean
    public Consumer<OrderCreatedEvent> handleOrderCreated() {
        return event -> {
            // Service account ile Ã§alÄ±ÅŸÄ±r
            // Token Keycloak'tan otomatik alÄ±nÄ±r (client_credentials grant)
            inventoryClient.reserveStock(event, serviceAccountToken);
        };
    }
}
```

**Not**: Service-to-service Ã§aÄŸrÄ±lar iÃ§in Keycloak'ta "Service Accounts Enabled" aÃ§Ä±k olmalÄ±.

---

## 6ï¸âƒ£ TEST SENARYOLARI

### 6.1 Postman ile Token Alma

```bash
POST http://localhost:8180/realms/ecommerce/protocol/openid-connect/token
Content-Type: application/x-www-form-urlencoded

grant_type=password
client_id=gateway-client
client_secret=<CLIENT_SECRET>
username=customer1
password=customer123
```

**Response:**
```json
{
  "access_token": "eyJhbGciOiJSUzI1NiIsInR5cCI...",
  "expires_in": 900,
  "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI...",
  "token_type": "Bearer"
}
```

---

### 6.2 API Ã‡aÄŸrÄ±sÄ± (Bearer Token ile)

```bash
POST http://localhost:8080/api/v1/orders
Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI...
Content-Type: application/json

{
  "customerId": "cust-123",
  "deliveryAddress": {
    "street": "123 Main St",
    "city": "Istanbul",
    "zipCode": "34000",
    "country": "Turkey"
  },
  "items": [
    {
      "productId": "prod-1",
      "quantity": 2,
      "unitPrice": 100.00
    }
  ]
}
```

---

### 6.3 Role Testi

**Test 1: Customer â†’ Admin endpoint (401 beklenir)**
```bash
PATCH http://localhost:8080/api/v1/orders/{id}/status
Authorization: Bearer <CUSTOMER_TOKEN>

# Expected: 403 Forbidden
```

**Test 2: Admin â†’ TÃ¼m endpoint'ler (200 OK)**
```bash
PATCH http://localhost:8080/api/v1/orders/{id}/status
Authorization: Bearer <ADMIN_TOKEN>

# Expected: 200 OK
```

---

## ğŸ¯ Ã–ZET CHECKLIST

### Keycloak Admin Panel
- [ ] Realm: `ecommerce` oluÅŸturuldu
- [ ] Clients: `gateway-client`, order-service, inventory-service tanÄ±mlandÄ±
- [ ] Roles: `ROLE_CUSTOMER`, `ROLE_ADMIN`, `ROLE_INVENTORY_MANAGER`, `ROLE_ORDER_MANAGER` oluÅŸturuldu
- [ ] Users: `admin`, `customer1`, `inventory_manager` eklendi
- [ ] Token ayarlarÄ± yapÄ±landÄ±rÄ±ldÄ±

### Gateway Service
- [ ] pom.xml: OAuth2 Client dependencies eklendi
- [ ] application.yml: Keycloak issuer-uri yapÄ±landÄ±rÄ±ldÄ±
- [ ] `SecurityConfig.java`: JWT validation eklendi
- [ ] Routes'a `TokenRelay` filter eklendi

### Order Service
- [ ] pom.xml: Resource Server dependencies eklendi
- [ ] application.yml: JWT issuer-uri yapÄ±landÄ±rÄ±ldÄ±
- [ ] `SecurityConfig.java`: Method security aktif
- [ ] OrderController.java: `@PreAuthorize` annotations eklendi

### Inventory Service
- [ ] pom.xml: Resource Server dependencies eklendi
- [ ] application.yml: JWT issuer-uri yapÄ±landÄ±rÄ±ldÄ±
- [ ] `SecurityConfig.java`: Method security aktif
- [ ] InventoryController.java: `@PreAuthorize` annotations eklendi

### Test
- [ ] Token alma testi baÅŸarÄ±lÄ±
- [ ] API Ã§aÄŸrÄ±larÄ± Bearer token ile Ã§alÄ±ÅŸÄ±yor
- [ ] Role-based access control doÄŸru Ã§alÄ±ÅŸÄ±yor
- [ ] Service-to-service communication saÄŸlÄ±klÄ±

---

## ğŸ“š EK KAYNAKLAR

- Keycloak Docs: https://www.keycloak.org/docs/26.5.1/
- Spring Security OAuth2: https://docs.spring.io/spring-security/reference/servlet/oauth2/index.html
- JWT Debugger: https://jwt.io

---

**ğŸ“ Senior Developer Notu**: Bu entegrasyon production-ready deÄŸildir. Production'da:
- HTTPS kullanÄ±n (TLS)
- Keycloak'Ä± HA (High Availability) modda kurun
- External PostgreSQL kullanÄ±n (cluster)
- Rate limiting ekleyin
- Audit logging aktif edin
- Token refresh mekanizmasÄ± ekleyin

Similar code found with 4 license types

User: Role yapÄ±sÄ± yerine `Operation Claim` mantÄ±ÄŸÄ± ile ilerlesek Ã§ok daha iyi olmaz mÄ±? Daha flexible bir rol tanÄ±mlama yapÄ±sÄ± istiyorum (Product.Create,Product.Delete etc..)

GitHub Copilot: Kesinlikle haklÄ±sÄ±nÄ±z! ğŸ¯ **Operation-Based Claims (Fine-Grained Permissions)** yaklaÅŸÄ±mÄ± Ã§ok daha profesyonel ve Ã¶lÃ§eklenebilir bir Ã§Ã¶zÃ¼mdÃ¼r.

---

# ğŸ” OPERATION-BASED CLAIMS (FINE-GRAINED PERMISSIONS) MÄ°MARÄ°SÄ°

---

## 1ï¸âƒ£ ROLE vs OPERATION CLAIM KARÅILAÅTIRMASI

### âŒ Role-Based (Eski YaklaÅŸÄ±m)

```
ROLE_ADMIN â†’ TÃ¼m yetkiler
ROLE_CUSTOMER â†’ Sadece okuma

Problem:
- GranÃ¼ler kontrol yok
- Bir admin'in sadece product.read yetkisi olabilir mi? â†’ HAYIR
- Esneklik dÃ¼ÅŸÃ¼k
```

### âœ… Operation-Based Claims (Modern YaklaÅŸÄ±m)

```
User â†’ Claims:
  - order.create
  - order.read
  - order.update
  - inventory.read
  - product.delete

Avantajlar:
- âœ… Fine-grained control
- âœ… Ã‡ok esnek yetkilendirme
- âœ… Business ihtiyaÃ§larÄ±na gÃ¶re kombinasyon
- âœ… Principle of Least Privilege
```

---

## 2ï¸âƒ£ OPERATION CLAIMS TANIMLAMA STRATEJÄ°SÄ°

### 2.1 Claim Naming Convention

**Format**: `<resource>.<operation>`

#### Order Service Claims
```
order.create          â†’ SipariÅŸ oluÅŸturma
order.read            â†’ SipariÅŸ gÃ¶rÃ¼ntÃ¼leme
order.read.own        â†’ Sadece kendi sipariÅŸlerini gÃ¶rme
order.read.all        â†’ TÃ¼m sipariÅŸleri gÃ¶rme
order.update          â†’ SipariÅŸ gÃ¼ncelleme
order.cancel          â†’ SipariÅŸ iptal etme
order.delete          â†’ SipariÅŸ silme
order.status.update   â†’ SipariÅŸ durumu gÃ¼ncelleme
```

#### Inventory Service Claims
```
inventory.read        â†’ Stok bilgisi gÃ¶rÃ¼ntÃ¼leme
inventory.write       â†’ Stok gÃ¼ncelleme
inventory.create      â†’ ÃœrÃ¼n ekleme
inventory.delete      â†’ ÃœrÃ¼n silme
reservation.create    â†’ Rezervasyon oluÅŸturma
reservation.read      â†’ Rezervasyon gÃ¶rÃ¼ntÃ¼leme
reservation.confirm   â†’ Rezervasyon onaylama
reservation.cancel    â†’ Rezervasyon iptal etme
```

#### Product Service Claims (Gelecek iÃ§in)
```
product.create        â†’ ÃœrÃ¼n ekleme
product.read          â†’ ÃœrÃ¼n gÃ¶rÃ¼ntÃ¼leme
product.update        â†’ ÃœrÃ¼n gÃ¼ncelleme
product.delete        â†’ ÃœrÃ¼n silme
product.price.update  â†’ Fiyat gÃ¼ncelleme
```

---

### 2.2 Claim GruplarÄ± (Composite Roles)

Keycloak'ta **Composite Roles** ile claim gruplarÄ± oluÅŸturulur:

```
CustomerRole (Composite) â†’ Contains:
  - order.create
  - order.read.own
  - order.cancel
  - inventory.read
  - product.read

AdminRole (Composite) â†’ Contains:
  - order.*              (tÃ¼m order claims)
  - inventory.*          (tÃ¼m inventory claims)
  - product.*            (tÃ¼m product claims)

InventoryManagerRole (Composite) â†’ Contains:
  - inventory.read
  - inventory.write
  - reservation.read
  - reservation.confirm
  - reservation.cancel
```

---

## 3ï¸âƒ£ KEYCLOAK ADMÄ°N PANEL ADIMLARI (YENÄ°DEN)

### ğŸ“Œ ADIM 1: Client Roles OluÅŸturma (Her Servis Ä°Ã§in)

#### 1.1 Order Service Client Roles

1. **Clients** â†’ **order-service** â†’ **Roles** tab
2. **Create role** ile aÅŸaÄŸÄ±daki rolleri oluÅŸturun:

| Role Name | Description |
|-----------|-------------|
| `order.create` | Create new orders |
| `order.read` | Read order details |
| `order.read.own` | Read own orders only |
| `order.read.all` | Read all orders |
| `order.update` | Update order information |
| `order.cancel` | Cancel orders |
| `order.delete` | Delete orders |
| `order.status.update` | Update order status |

---

#### 1.2 Inventory Service Client Roles

1. **Clients** â†’ **inventory-service** â†’ **Roles** tab
2. AÅŸaÄŸÄ±daki rolleri oluÅŸturun:

| Role Name | Description |
|-----------|-------------|
| `inventory.read` | Read inventory data |
| `inventory.write` | Update inventory data |
| `inventory.create` | Create inventory items |
| `inventory.delete` | Delete inventory items |
| `reservation.create` | Create reservations |
| `reservation.read` | Read reservations |
| `reservation.confirm` | Confirm reservations |
| `reservation.cancel` | Cancel reservations |

---

### ğŸ“Œ ADIM 2: Composite Roles (Realm Level)

1. **Realm roles** â†’ **Create role**
2. **Customer** composite role oluÅŸturun:

**Customer Role:**
- **Role name**: `Customer`
- **Composite**: `ON`
- **Save**
- **Associated roles** tab:
  - **Filter by clients** â†’ order-service:
    - `order.create`
    - `order.read.own`
    - `order.cancel`
  - **Filter by clients** â†’ inventory-service:
    - `inventory.read`
    - `reservation.create`

---

**Admin Role:**
- **Role name**: `Admin`
- **Composite**: `ON`
- **Save**
- **Associated roles** tab:
  - **Filter by clients** â†’ order-service: âœ“ **TÃ¼m claims**
  - **Filter by clients** â†’ inventory-service: âœ“ **TÃ¼m claims**

---

**InventoryManager Role:**
- **Role name**: `InventoryManager`
- **Composite**: `ON`
- **Associated roles**:
  - `inventory.read`
  - `inventory.write`
  - `inventory.create`
  - `reservation.read`
  - `reservation.confirm`
  - `reservation.cancel`

---

**OrderManager Role:**
- **Role name**: `OrderManager`
- **Composite**: `ON`
- **Associated roles**:
  - `order.read.all`
  - `order.update`
  - `order.status.update`
  - `order.cancel`

---

### ğŸ“Œ ADIM 3: Client Scope Mappers (JWT Token'a Claims Ekleme)

JWT token'da client roles'larÄ± gÃ¶stermek iÃ§in mapper ekliyoruz:

#### 3.1 Order Service Mapper

1. **Clients** â†’ **order-service** â†’ **Client scopes** tab
2. **order-service-dedicated** scope'a tÄ±klayÄ±n
3. **Add mapper** â†’ **By configuration** â†’ **User Client Role**
4. Mapper bilgileri:
   - **Name**: `order-service-roles`
   - **Client ID**: order-service
   - **Token Claim Name**: `order_claims`
   - **Claim JSON Type**: `String`
   - **Add to ID token**: `ON`
   - **Add to access token**: `ON`
   - **Add to userinfo**: `ON`
   - **Save**

---

#### 3.2 Inventory Service Mapper

1. **Clients** â†’ **inventory-service** â†’ **Client scopes** tab
2. **inventory-service-dedicated** scope'a tÄ±klayÄ±n
3. **Add mapper** â†’ **By configuration** â†’ **User Client Role**
4. Mapper bilgileri:
   - **Name**: `inventory-service-roles`
   - **Client ID**: inventory-service
   - **Token Claim Name**: `inventory_claims`
   - **Claim JSON Type**: `String`
   - **Add to ID token**: `ON`
   - **Add to access token**: `ON`
   - **Save**

---

### ğŸ“Œ ADIM 4: KullanÄ±cÄ±lara Composite Role Atama

#### 4.1 Admin User

1. **Users** â†’ **admin** â†’ **Role mapping** tab
2. **Assign role** â†’ `Admin` (composite role)
3. **Assign**

#### 4.2 Customer User

1. **Users** â†’ **customer1** â†’ **Role mapping** tab
2. **Assign role** â†’ `Customer` (composite role)
3. **Assign**

#### 4.3 Inventory Manager User

1. **Users** â†’ **inventory_manager** â†’ **Role mapping** tab
2. **Assign role** â†’ `InventoryManager` (composite role)
3. **Assign**

---

## 4ï¸âƒ£ JWT TOKEN YAPISINDA DEÄÄ°ÅÄ°KLÄ°K

### 4.1 Yeni Token Anatomisi

```json
{
  "sub": "user-uuid",
  "preferred_username": "customer1",
  "email": "customer1@test.com",
  
  "realm_access": {
    "roles": ["Customer"]
  },
  
  "resource_access": {
    "order-service": {
      "roles": [
        "order.create",
        "order.read.own",
        "order.cancel"
      ]
    },
    "inventory-service": {
      "roles": [
        "inventory.read",
        "reservation.create"
      ]
    }
  },
  
  "order_claims": [
    "order.create",
    "order.read.own",
    "order.cancel"
  ],
  
  "inventory_claims": [
    "inventory.read",
    "reservation.create"
  ]
}
```

---

## 5ï¸âƒ£ SPRING SECURITY YAPILANDIRMASI

### 5.1 Custom JWT Converter (Her Servis Ä°Ã§in)

#### `JwtClaimsConverter.java` (order-service)

```java
package com.ecommerce.orderservice.config;

import org.springframework.core.convert.converter.Converter;
import org.springframework.security.authentication.AbstractAuthenticationToken;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Component
public class JwtClaimsConverter implements Converter<Jwt, AbstractAuthenticationToken> {

    @Override
    public AbstractAuthenticationToken convert(Jwt jwt) {
        Collection<GrantedAuthority> authorities = extractAuthorities(jwt);
        return new JwtAuthenticationToken(jwt, authorities);
    }

    private Collection<GrantedAuthority> extractAuthorities(Jwt jwt) {
        // 1. Realm-level composite roles (opsiyonel)
        List<String> realmRoles = extractRealmRoles(jwt);
        
        // 2. Client-specific claims (asÄ±l yetkiler)
        List<String> orderClaims = extractOrderClaims(jwt);
        
        // 3. Resource access (alternatif yÃ¶ntem)
        List<String> resourceAccessClaims = extractResourceAccessClaims(jwt, "order-service");
        
        // TÃ¼m claim'leri birleÅŸtir
        return orderClaims.stream()
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());
    }

    private List<String> extractRealmRoles(Jwt jwt) {
        Map<String, Object> realmAccess = jwt.getClaim("realm_access");
        if (realmAccess == null) {
            return Collections.emptyList();
        }
        
        @SuppressWarnings("unchecked")
        List<String> roles = (List<String>) realmAccess.get("roles");
        return roles != null ? roles : Collections.emptyList();
    }

    private List<String> extractOrderClaims(Jwt jwt) {
        List<String> claims = jwt.getClaim("order_claims");
        return claims != null ? claims : Collections.emptyList();
    }

    private List<String> extractResourceAccessClaims(Jwt jwt, String clientId) {
        Map<String, Object> resourceAccess = jwt.getClaim("resource_access");
        if (resourceAccess == null) {
            return Collections.emptyList();
        }
        
        @SuppressWarnings("unchecked")
        Map<String, Object> clientResource = (Map<String, Object>) resourceAccess.get(clientId);
        if (clientResource == null) {
            return Collections.emptyList();
        }
        
        @SuppressWarnings("unchecked")
        List<String> roles = (List<String>) clientResource.get("roles");
        return roles != null ? roles : Collections.emptyList();
    }
}
```

---

### 5.2 Updated SecurityConfig (order-service)

```java
package com.ecommerce.orderservice.config;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtClaimsConverter jwtClaimsConverter;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/actuator/**", "/v3/api-docs/**", "/swagger-ui/**").permitAll()
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(jwt -> jwt.jwtAuthenticationConverter(jwtClaimsConverter))
            );
        
        return http.build();
    }
}
```

---

### 5.3 Controller Updates (order-service)

```java
package com.ecommerce.orderservice.web.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.util.UUID;

@RestController
@RequestMapping("/api/v1/orders")
@RequiredArgsConstructor
@Validated
public class OrderController {

    private final CreateOrderUseCase createOrderUseCase;
    private final GetOrderUseCase getOrderUseCase;
    private final CancelOrderUseCase cancelOrderUseCase;
    private final UpdateOrderStatusUseCase updateOrderStatusUseCase;

    /**
     * CREATE ORDER
     * Required claim: order.create
     */
    @PostMapping
    @PreAuthorize("hasAuthority('order.create')")
    public ResponseEntity<OrderResponseDto> createOrder(
            @Valid @RequestBody OrderRequestDto request,
            @AuthenticationPrincipal Jwt jwt) {
        
        String userId = jwt.getSubject();
        String username = jwt.getClaimAsString("preferred_username");
        
        OrderResponseDto response = createOrderUseCase.execute(request, userId, username);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    /**
     * GET ORDER BY ID
     * Required claims: 
     * - order.read.own (kullanÄ±cÄ± sadece kendi sipariÅŸini gÃ¶rebilir)
     * - order.read.all (tÃ¼m sipariÅŸleri gÃ¶rebilir)
     */
    @GetMapping("/{id}")
    @PreAuthorize("hasAnyAuthority('order.read.own', 'order.read.all')")
    public ResponseEntity<OrderResponseDto> getOrder(
            @PathVariable UUID id,
            @AuthenticationPrincipal Jwt jwt) {
        
        String userId = jwt.getSubject();
        boolean canReadAll = jwt.getClaim("order_claims") != null &&
                ((List<String>) jwt.getClaim("order_claims")).contains("order.read.all");
        
        OrderResponseDto response = getOrderUseCase.execute(id, userId, canReadAll);
        return ResponseEntity.ok(response);
    }

    /**
     * CANCEL ORDER
     * Required claim: order.cancel
     */
    @PostMapping("/{id}/cancel")
    @PreAuthorize("hasAuthority('order.cancel')")
    public ResponseEntity<CancelOrderResponseDto> cancelOrder(
            @PathVariable UUID id,
            @AuthenticationPrincipal Jwt jwt) {
        
        String userId = jwt.getSubject();
        CancelOrderResponseDto response = cancelOrderUseCase.execute(id, userId);
        return ResponseEntity.ok(response);
    }

    /**
     * UPDATE ORDER STATUS
     * Required claim: order.status.update
     * Typically only for admins/managers
     */
    @PatchMapping("/{id}/status")
    @PreAuthorize("hasAuthority('order.status.update')")
    public ResponseEntity<OrderResponseDto> updateOrderStatus(
            @PathVariable UUID id,
            @Valid @RequestBody UpdateStatusRequestDto request,
            @AuthenticationPrincipal Jwt jwt) {
        
        String performedBy = jwt.getClaimAsString("preferred_username");
        OrderResponseDto response = updateOrderStatusUseCase.execute(id, request, performedBy);
        return ResponseEntity.ok(response);
    }

    /**
     * DELETE ORDER
     * Required claim: order.delete
     * Typically only for admins
     */
    @DeleteMapping("/{id}")
    @PreAuthorize("hasAuthority('order.delete')")
    public ResponseEntity<Void> deleteOrder(
            @PathVariable UUID id,
            @AuthenticationPrincipal Jwt jwt) {
        
        // Implementation
        return ResponseEntity.noContent().build();
    }
}
```

---

### 5.4 Inventory Service - JwtClaimsConverter

```java
package com.ecommerce.inventoryservice.config;

import org.springframework.core.convert.converter.Converter;
import org.springframework.security.authentication.AbstractAuthenticationToken;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

@Component
public class JwtClaimsConverter implements Converter<Jwt, AbstractAuthenticationToken> {

    @Override
    public AbstractAuthenticationToken convert(Jwt jwt) {
        Collection<GrantedAuthority> authorities = extractAuthorities(jwt);
        return new JwtAuthenticationToken(jwt, authorities);
    }

    private Collection<GrantedAuthority> extractAuthorities(Jwt jwt) {
        // inventory_claims'den yetkileri Ã§ek
        List<String> inventoryClaims = jwt.getClaim("inventory_claims");
        if (inventoryClaims == null) {
            inventoryClaims = Collections.emptyList();
        }
        
        return inventoryClaims.stream()
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());
    }
}
```

---

### 5.5 Inventory Controller Updates

```java
package com.ecommerce.inventoryservice.web.controller;

import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.util.UUID;

@RestController
@RequestMapping("/api/v1")
@RequiredArgsConstructor
@Validated
public class InventoryController {

    private final GetInventoryItemUseCase getInventoryItemUseCase;
    private final CheckAvailabilityUseCase checkAvailabilityUseCase;
    private final ReserveStockUseCase reserveStockUseCase;
    private final GetReservationUseCase getReservationUseCase;
    private final ConfirmReservationUseCase confirmReservationUseCase;
    private final CancelReservationUseCase cancelReservationUseCase;

    /**
     * GET INVENTORY ITEM
     * Required claim: inventory.read
     */
    @GetMapping("/inventory/items/{productId}")
    @PreAuthorize("hasAuthority('inventory.read')")
    public ResponseEntity<InventoryItemResponse> getInventoryItem(
            @PathVariable UUID productId,
            @AuthenticationPrincipal Jwt jwt) {
        
        InventoryItemResponse response = getInventoryItemUseCase.execute(productId);
        return ResponseEntity.ok(response);
    }

    /**
     * CHECK AVAILABILITY
     * Required claim: inventory.read (herkes okuyabilir)
     */
    @PostMapping("/inventory/check-availability")
    @PreAuthorize("hasAuthority('inventory.read')")
    public ResponseEntity<AvailabilityCheckResponse> checkAvailability(
            @Valid @RequestBody AvailabilityCheckRequest request,
            @AuthenticationPrincipal Jwt jwt) {
        
        AvailabilityCheckResponse response = checkAvailabilityUseCase.execute(request);
        return ResponseEntity.ok(response);
    }

    /**
     * CREATE RESERVATION
     * Required claim: reservation.create
     */
    @PostMapping("/reservations")
    @PreAuthorize("hasAuthority('reservation.create')")
    public ResponseEntity<StockReservationResponse> createReservation(
            @Valid @RequestBody StockReservationRequest request,
            @AuthenticationPrincipal Jwt jwt) {
        
        String userId = jwt.getSubject();
        StockReservationResponse response = reserveStockUseCase.execute(request, userId);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    /**
     * GET RESERVATION
     * Required claim: reservation.read
     */
    @GetMapping("/reservations/{reservationId}")
    @PreAuthorize("hasAuthority('reservation.read')")
    public ResponseEntity<StockReservationResponse> getReservation(
            @PathVariable UUID reservationId,
            @AuthenticationPrincipal Jwt jwt) {
        
        StockReservationResponse response = getReservationUseCase.execute(reservationId);
        return ResponseEntity.ok(response);
    }

    /**
     * CONFIRM RESERVATION
     * Required claim: reservation.confirm
     */
    @PostMapping("/reservations/{reservationId}/confirm")
    @PreAuthorize("hasAuthority('reservation.confirm')")
    public ResponseEntity<StockReservationResponse> confirmReservation(
            @PathVariable UUID reservationId,
            @AuthenticationPrincipal Jwt jwt) {
        
        String performedBy = jwt.getClaimAsString("preferred_username");
        StockReservationResponse response = confirmReservationUseCase.execute(reservationId, performedBy);
        return ResponseEntity.ok(response);
    }

    /**
     * CANCEL RESERVATION
     * Required claim: reservation.cancel
     */
    @PostMapping("/reservations/{reservationId}/cancel")
    @PreAuthorize("hasAuthority('reservation.cancel')")
    public ResponseEntity<Void> cancelReservation(
            @PathVariable UUID reservationId,
            @AuthenticationPrincipal Jwt jwt) {
        
        String performedBy = jwt.getClaimAsString("preferred_username");
        cancelReservationUseCase.execute(reservationId, performedBy);
        return ResponseEntity.noContent().build();
    }

    /**
     * UPDATE INVENTORY (Create/Update)
     * Required claim: inventory.write
     */
    @PutMapping("/inventory/items/{productId}")
    @PreAuthorize("hasAuthority('inventory.write')")
    public ResponseEntity<InventoryItemResponse> updateInventory(
            @PathVariable UUID productId,
            @Valid @RequestBody UpdateInventoryRequest request,
            @AuthenticationPrincipal Jwt jwt) {
        
        // Implementation
        return ResponseEntity.ok(new InventoryItemResponse());
    }

    /**
     * DELETE INVENTORY ITEM
     * Required claim: inventory.delete
     */
    @DeleteMapping("/inventory/items/{productId}")
    @PreAuthorize("hasAuthority('inventory.delete')")
    public ResponseEntity<Void> deleteInventoryItem(
            @PathVariable UUID productId,
            @AuthenticationPrincipal Jwt jwt) {
        
        // Implementation
        return ResponseEntity.noContent().build();
    }
}
```

---

## 6ï¸âƒ£ GATEWAY SERVICE YAPILANDIRMASI

### 6.1 Gateway SecurityConfig (Operation Claims ile)

```java
package com.ecommerce.gateway.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.web.server.SecurityWebFilterChain;

@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        http
            .csrf(csrf -> csrf.disable())
            .authorizeExchange(exchanges -> exchanges
                // Public endpoints
                .pathMatchers("/actuator/**", "/login/**", "/oauth2/**").permitAll()
                
                // Order endpoints - operation-based
                .pathMatchers("/api/v1/orders").hasAuthority("order.create")
                .pathMatchers("/api/v1/orders/{id}").hasAnyAuthority("order.read.own", "order.read.all")
                .pathMatchers("/api/v1/orders/{id}/cancel").hasAuthority("order.cancel")
                .pathMatchers("/api/v1/orders/{id}/status").hasAuthority("order.status.update")
                
                // Inventory endpoints - operation-based
                .pathMatchers("/api/v1/inventory/items/**").hasAuthority("inventory.read")
                .pathMatchers("/api/v1/inventory/check-availability").hasAuthority("inventory.read")
                
                // Reservation endpoints
                .pathMatchers("/api/v1/reservations").hasAuthority("reservation.create")
                .pathMatchers("/api/v1/reservations/{id}").hasAuthority("reservation.read")
                .pathMatchers("/api/v1/reservations/{id}/confirm").hasAuthority("reservation.confirm")
                .pathMatchers("/api/v1/reservations/{id}/cancel").hasAuthority("reservation.cancel")
                
                // Default: authenticated
                .anyExchange().authenticated()
            )
            .oauth2Login(oauth2 -> oauth2.loginPage("/oauth2/authorization/keycloak"))
            .oauth2ResourceServer(oauth2 -> oauth2.jwt());
        
        return http.build();
    }
}
```

---

## 7ï¸âƒ£ PERMISSION MATRIX (OPERATION-BASED)

| Claim | Customer | Admin | OrderManager | InventoryManager |
|-------|----------|-------|--------------|------------------|
| **order.create** | âœ“ | âœ“ | âœ“ | âœ— |
| **order.read.own** | âœ“ | âœ— | âœ— | âœ— |
| **order.read.all** | âœ— | âœ“ | âœ“ | âœ— |
| **order.cancel** | âœ“ | âœ“ | âœ“ | âœ— |
| **order.status.update** | âœ— | âœ“ | âœ“ | âœ— |
| **order.delete** | âœ— | âœ“ | âœ— | âœ— |
| **inventory.read** | âœ“ | âœ“ | âœ— | âœ“ |
| **inventory.write** | âœ— | âœ“ | âœ— | âœ“ |
| **inventory.create** | âœ— | âœ“ | âœ— | âœ“ |
| **inventory.delete** | âœ— | âœ“ | âœ— | âœ— |
| **reservation.create** | âœ“ | âœ“ | âœ“ | âœ— |
| **reservation.read** | âœ— | âœ“ | âœ“ | âœ“ |
| **reservation.confirm** | âœ— | âœ“ | âœ— | âœ“ |
| **reservation.cancel** | âœ— | âœ“ | âœ“ | âœ“ |

---

## 8ï¸âƒ£ TEST SENARYOLARI

### Test 1: Customer Token â†’ Order Create (Success)

```bash
POST http://localhost:8080/api/v1/orders
Authorization: Bearer <CUSTOMER_TOKEN>

Expected: 201 CREATED
```

### Test 2: Customer Token â†’ Order Status Update (Fail)

```bash
PATCH http://localhost:8080/api/v1/orders/{id}/status
Authorization: Bearer <CUSTOMER_TOKEN>

Expected: 403 FORBIDDEN (missing claim: order.status.update)
```

### Test 3: InventoryManager â†’ Inventory Read (Success)

```bash
GET http://localhost:8080/api/v1/inventory/items/{productId}
Authorization: Bearer <INVENTORY_MANAGER_TOKEN>

Expected: 200 OK
```

### Test 4: Customer â†’ Inventory Write (Fail)

```bash
PUT http://localhost:8080/api/v1/inventory/items/{productId}
Authorization: Bearer <CUSTOMER_TOKEN>

Expected: 403 FORBIDDEN (missing claim: inventory.write)
```

---

## 9ï¸âƒ£ AVANTAJLAR & BEST PRACTICES

### âœ… Avantajlar

1. **Fine-Grained Control**: Her endpoint iÃ§in hassas yetki kontrolÃ¼
2. **Flexibility**: Business ihtiyaÃ§larÄ±na gÃ¶re kombinasyonlar
3. **Scalability**: Yeni claim'ler kolayca eklenebilir
4. **Least Privilege**: KullanÄ±cÄ±lara minimum gerekli yetki
5. **Audit Trail**: Her claim kullanÄ±mÄ± loglanabilir

### ğŸ¯ Best Practices

1. **Claim Naming**: TutarlÄ± isimlendirme (`resource.operation`)
2. **Composite Roles**: SÄ±k kullanÄ±lan kombinasyonlar iÃ§in
3. **Default Deny**: AÃ§Ä±kÃ§a izin verilmeyen her ÅŸey yasak
4. **Token Scope**: Token'larda sadece gerekli claim'ler
5. **Documentation**: TÃ¼m claim'lerin dokÃ¼mantasyonu

---

## ğŸ“ Ã–ZET

Operation-based claims ile:
- âœ… RBAC'den daha esnek bir yetkilendirme
- âœ… Keycloak'ta Client Roles + Composite Roles
- âœ… JWT token'da `resource_access` ve custom claims
- âœ… Spring Security'de `@PreAuthorize("hasAuthority('claim')")`
- âœ… Fine-grained permission control

Bu yaklaÅŸÄ±m enterprise-grade projelerde tercih edilir! ğŸš€

Similar code found with 4 license types

User: Åimdi bu konuÅŸtuklarÄ±mÄ±zÄ± bu chat sessionda kalmasÄ±n, entegrasyon rehberi olmasÄ± adÄ±na ve gelecekte entegrasyon deÄŸiÅŸikliklerini daha kolay uygulayabilmemiz adÄ±na bu projenin `docs/` klasÃ¶rÃ¼, AGENTS.md dosyasÄ±, DECISIONS.md dosyasÄ± gibi dosyalarÄ±nÄ± bu entegrasyonu yapacak ve yeni entegrasyonlarda bunlarÄ± hatÄ±rlayacak ÅŸekilde dosyalarÄ±mÄ± dÃ¼zenlemeni istiyorum. Åu anda yapma, yapacaklarÄ±nÄ± anlat. Onaylarsam yapacaÄŸÄ±z.

GitHub Copilot: MÃ¼kemmel bir yaklaÅŸÄ±m! ğŸ¯ Åimdi yapacaÄŸÄ±m deÄŸiÅŸiklikleri detaylÄ±ca aÃ§Ä±klÄ±yorum:

---

## ğŸ“‹ DOKÃœMANTASYON PLANI

### 1ï¸âƒ£ YENÄ° DOSYA YAPISI

```
docs/
â”œâ”€â”€ security/                              [YENÄ° KLASÃ–R]
â”‚   â”œâ”€â”€ keycloak-integration.md           [YENÄ°] - Ana entegrasyon rehberi
â”‚   â”œâ”€â”€ operation-claims-guide.md         [YENÄ°] - Operation-based claims detayÄ±
â”‚   â”œâ”€â”€ jwt-token-structure.md            [YENÄ°] - Token anatomisi ve claims
â”‚   â””â”€â”€ security-testing-guide.md         [YENÄ°] - Test senaryolarÄ±
â”‚
â”œâ”€â”€ architecture/
â”‚   â”œâ”€â”€ optimistic-locking-guidelines.md  [MEVCUT]
â”‚   â””â”€â”€ security-architecture.md          [YENÄ°] - GÃ¼venlik mimarisi ADR
â”‚
â”œâ”€â”€ openapi/
â”‚   â”œâ”€â”€ order-service.yaml                [GÃœNCELLENECEK] - Security schemes ekle
â”‚   â””â”€â”€ inventory-service.yaml            [GÃœNCELLENECEK] - Security schemes ekle
â”‚
AGENTS.md                                  [GÃœNCELLENECEK] - Security rules ekle
DECISIONS.md                               [GÃœNCELLENECEK] - Keycloak kararÄ± ekle
```

---

### 2ï¸âƒ£ OLUÅTURULACAK/GÃœNCELLENECEKdosyalar

#### ğŸ“„ **docs/security/keycloak-integration.md** [YENÄ°]
**Ä°Ã§erik:**
- Keycloak 26.5.1 kurulum adÄ±mlarÄ± (Docker Compose)
- Realm yapÄ±landÄ±rmasÄ± (`ecommerce`)
- Client tanÄ±mlarÄ± (gateway, order-service, inventory-service)
- Operation claims yapÄ±sÄ±
- Composite roles
- Client scope mappers
- KullanÄ±cÄ± oluÅŸturma ÅŸablonlarÄ±
- Token endpoint kullanÄ±mÄ±
- Troubleshooting

**AmaÃ§:** Gelecekte baÅŸka bir developer veya AI agent bu dosyayÄ± okuyarak sÄ±fÄ±rdan Keycloak entegrasyonu yapabilsin.

---

#### ğŸ“„ **docs/security/operation-claims-guide.md** [YENÄ°]
**Ä°Ã§erik:**
- Operation-based claims felsefesi
- Claim naming convention (`resource.operation`)
- TÃ¼m claims listesi:
  - Order claims (order.create, order.read.own, order.read.all, vb.)
  - Inventory claims (inventory.read, inventory.write, vb.)
  - Reservation claims (reservation.create, reservation.confirm, vb.)
- Composite role Ã¶rnekleri (Customer, Admin, OrderManager, InventoryManager)
- Permission matrix tablosu
- Yeni claim ekleme prosedÃ¼rÃ¼

**AmaÃ§:** Yeni bir resource eklendiÄŸinde (Ã¶rn: product-service) claim yapÄ±sÄ±nÄ±n nasÄ±l geniÅŸletileceÄŸini gÃ¶stermek.

---

#### ğŸ“„ **docs/security/jwt-token-structure.md** [YENÄ°]
**Ä°Ã§erik:**
- JWT token anatomisi (Ã¶rnek payload)
- Standard claims (sub, iss, exp, iat)
- Custom claims (order_claims, inventory_claims)
- realm_access vs resource_access farkÄ±
- Token validation sÃ¼reci
- Token refresh mekanizmasÄ±
- Token lifespan ayarlarÄ±

**AmaÃ§:** Token iÃ§eriÄŸini anlamak ve debug yaparken faydalÄ± olmasÄ±.

---

#### ğŸ“„ **docs/security/security-testing-guide.md** [YENÄ°]
**Ä°Ã§erik:**
- Postman collection Ã¶rnekleri
- Token alma (password grant)
- API Ã§aÄŸrÄ±larÄ± (Bearer token ile)
- Positive test cases (yetkili kullanÄ±cÄ±)
- Negative test cases (403 Forbidden)
- Role/claim bazlÄ± test matrisi
- Curl komut Ã¶rnekleri
- Automated test stratejisi

**AmaÃ§:** Entegrasyonun doÄŸru Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± test edebilmek.

---

#### ğŸ“„ **docs/architecture/security-architecture.md** [YENÄ° - ADR Format]
**Ä°Ã§erik (ADR-004 olarak):**
```markdown
# ADR-004: Keycloak ile Operation-Based Claims GÃ¼venlik Mimarisi

## Status
ACCEPTED - 2026-01-22

## Context
Mikroservis mimarimizde merkezi kimlik doÄŸrulama ve yetkilendirme ihtiyacÄ±.
Role-based access control yerine fine-grained permission kontrolÃ¼ gereksinimi.

## Decision
Keycloak 26.5.1 kullanarak OAuth2/OIDC tabanlÄ± gÃ¼venlik.
Operation-based claims (Ã¶rn: order.create, inventory.read) ile granular yetkilendirme.

## Consequences
### Positive
- Fine-grained permission control
- Centralized identity management
- Scalable authorization model

### Negative
- Initial setup complexity
- Token size increase
- Learning curve

## Implementation
[DetaylÄ± implementation adÄ±mlarÄ±]
```

**AmaÃ§:** Mimari karar olarak kayÄ±t altÄ±na almak (Architecture Decision Record).

---

#### ğŸ“„ **AGENTS.md** [GÃœNCELLENECEK]
**Eklenecek BÃ¶lÃ¼m (Yeni Section):**

```markdown
## 7) SECURITY & AUTHENTICATION

### 7.1 Keycloak Integration (MANDATORY)

ALL services MUST use Keycloak for authentication & authorization.

- **Keycloak Version**: 26.5.1
- **Realm**: `ecommerce`
- **Protocol**: OAuth2 / OpenID Connect
- **Token Type**: JWT (Bearer)

### 7.2 Operation-Based Claims (NOT Role-Based)

We use **operation-based claims** for fine-grained permissions:

âœ… **Correct**: `@PreAuthorize("hasAuthority('order.create')")`
âŒ **Wrong**: `@PreAuthorize("hasRole('ADMIN')")`

**Claim Naming Convention**: `<resource>.<operation>`
- Examples: `order.create`, `inventory.read`, `reservation.confirm`

See: `docs/security/operation-claims-guide.md` for complete list.

### 7.3 Service Layer Security

- **Gateway**: OAuth2 Client + Resource Server
  - Validates JWT tokens
  - Forwards tokens to downstream services (TokenRelay filter)
  
- **Backend Services**: Resource Server
  - Validate JWT signatures
  - Extract claims for authorization
  - Use `@PreAuthorize` on controller methods

### 7.4 Token Propagation

- Gateway MUST use `TokenRelay=` filter for all routes
- Backend services MUST extract user context from JWT:
  ```java
  @AuthenticationPrincipal Jwt jwt
  String userId = jwt.getSubject();
  List<String> claims = jwt.getClaim("order_claims");
  ```

### 7.5 Security Configuration Rules

- ALL endpoints (except actuator) MUST be authenticated
- Use `SessionCreationPolicy.STATELESS` (no server-side sessions)
- CSRF protection disabled (token-based security)
- NEVER store credentials in code/config (use environment variables)

### 7.6 Adding New Claims

When adding new endpoints/resources:
1. Define operation claims in Keycloak (client roles)
2. Update composite roles as needed
3. Add client scope mappers if using custom claim names
4. Update `JwtClaimsConverter` to extract new claims
5. Add `@PreAuthorize` annotations to controllers
6. Update `docs/security/operation-claims-guide.md`

See: `docs/security/keycloak-integration.md` for step-by-step guide.
```

**AmaÃ§:** AI agent veya developer'larÄ±n gÃ¼venlik kurallarÄ±nÄ± bilmesi ve uygulamasÄ±.

---

#### ğŸ“„ **DECISIONS.md** [GÃœNCELLENECEK]
**Eklenecek BÃ¶lÃ¼m:**

```markdown
## ADR-004: Keycloak ile Merkezi Kimlik YÃ¶netimi ve Operation-Based Claims

**Tarih**: 2026-01-22  
**Durum**: KABUL EDÄ°LDÄ°

### BaÄŸlam
Mikroservis mimarimizde gÃ¼venlik ve yetkilendirme iÃ§in merkezi bir Ã§Ã¶zÃ¼me ihtiyaÃ§ vardÄ±. 
Her servisin kendi kullanÄ±cÄ± yÃ¶netimini yapmasÄ±:
- Kod tekrarÄ±
- TutarsÄ±z gÃ¼venlik politikalarÄ±
- Single Sign-On (SSO) eksikliÄŸi
- Granular yetkilendirme zorluÄŸu

### Karar
**Keycloak 26.5.1** kullanarak OAuth2/OpenID Connect tabanlÄ± merkezi kimlik yÃ¶netimi.
**Operation-based claims** yapÄ±sÄ± ile fine-grained authorization.

**Teknoloji SeÃ§imi:**
- Keycloak: AÃ§Ä±k kaynak, endÃ¼stri standardÄ±, mature
- OAuth2/OIDC: Modern gÃ¼venlik protokolÃ¼
- JWT: Stateless token-based security

**Yetkilendirme Modeli:**
- âŒ Role-based (ROLE_ADMIN, ROLE_USER) â†’ Kaba, esnek deÄŸil
- âœ… Operation-based claims (order.create, inventory.read) â†’ Granular, esnek

### SonuÃ§lar

#### Olumlu
- Merkezi kullanÄ±cÄ± yÃ¶netimi (Single Source of Truth)
- Fine-grained permission control
- SSO desteÄŸi
- Sosyal medya login entegrasyonu hazÄ±r
- Token-based stateless security
- Scalable authorization model

#### Olumsuz
- Ä°lk kurulum karmaÅŸÄ±klÄ±ÄŸÄ±
- Token boyutu artÄ±ÅŸÄ± (claims eklendiÄŸinde)
- Ã–ÄŸrenme eÄŸrisi (OAuth2/OIDC)
- Keycloak'Ä±n ayrÄ± bir servis olarak yÃ¶netilmesi

### Uygulama
DetaylÄ± uygulama iÃ§in: `docs/security/keycloak-integration.md`

### Alternatifler
1. **Spring Security + Database**: Red edildi (her servis iÃ§in tekrar, SSO yok)
2. **Auth0/Okta**: Red edildi (Ã¼cretli, vendor lock-in)
3. **Custom OAuth2 Server**: Red edildi (reinventing the wheel)

### Ä°lgili DokÃ¼manlar
- `docs/security/keycloak-integration.md`
- `docs/security/operation-claims-guide.md`
- `docs/architecture/security-architecture.md`
```

**AmaÃ§:** Neden bu kararÄ± aldÄ±ÄŸÄ±mÄ±zÄ± ve alternatiflerini kayÄ±t altÄ±na almak.

---

#### ğŸ“„ **order-service.yaml** [GÃœNCELLENECEK]
**Eklenecek Security Scheme:**

```yaml
components:
  securitySchemes:
    keycloak_oauth:
      type: oauth2
      flows:
        authorizationCode:
          authorizationUrl: http://localhost:8180/realms/ecommerce/protocol/openid-connect/auth
          tokenUrl: http://localhost:8180/realms/ecommerce/protocol/openid-connect/token
          scopes:
            order.create: Create orders
            order.read: Read orders
            order.read.own: Read own orders
            order.read.all: Read all orders
            order.cancel: Cancel orders
            order.status.update: Update order status
            order.delete: Delete orders
    
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT

security:
  - keycloak_oauth: []
  - bearerAuth: []

paths:
  /api/v1/orders:
    post:
      security:
        - keycloak_oauth: [order.create]
      # ... rest of endpoint

  /api/v1/orders/{id}:
    get:
      security:
        - keycloak_oauth: [order.read, order.read.own, order.read.all]
      # ... rest of endpoint
```

**AmaÃ§:** OpenAPI spec'de gÃ¼venlik gereksinimlerini belgelemek, Swagger UI'da "Authorize" butonu Ã§alÄ±ÅŸsÄ±n.

---

#### ğŸ“„ **inventory-service.yaml** [GÃœNCELLENECEK]
**Eklenecek Security Scheme:**
```yaml
components:
  securitySchemes:
    keycloak_oauth:
      type: oauth2
      flows:
        authorizationCode:
          authorizationUrl: http://localhost:8180/realms/ecommerce/protocol/openid-connect/auth
          tokenUrl: http://localhost:8180/realms/ecommerce/protocol/openid-connect/token
          scopes:
            inventory.read: Read inventory
            inventory.write: Write inventory
            inventory.create: Create inventory items
            inventory.delete: Delete inventory items
            reservation.create: Create reservations
            reservation.read: Read reservations
            reservation.confirm: Confirm reservations
            reservation.cancel: Cancel reservations
```

---

### 3ï¸âƒ£ DOSYA GÃœNCELEME STRATEJÄ°SÄ°

#### **AGENTS.md**
- Mevcut 6 section var â†’ 7. section ekleyeceÄŸim
- "SECURITY & AUTHENTICATION" baÅŸlÄ±ÄŸÄ± altÄ±nda
- Keycloak zorunluluÄŸu, operation claims kurallarÄ±
- Token propagation kurallarÄ±

#### **DECISIONS.md**
- En alta ADR-004 olarak ekleyeceÄŸim
- ADR formatÄ±nda (Context, Decision, Consequences)
- Alternatif Ã§Ã¶zÃ¼mleri de belirtiyorum

#### **OpenAPI Files**
- Her iki YAML'a security schemes ekleyeceÄŸim
- OAuth2 flow tanÄ±mlarÄ±
- Scope listesi (claims)
- Endpoint-level security requirements

---

### 4ï¸âƒ£ BEKLENEN SONUÃ‡LAR

âœ… **Yeni Developer/AI Agent Senaryosu:**
```
1. AGENTS.md okur â†’ GÃ¼venlik kurallarÄ±nÄ± Ã¶ÄŸrenir
2. docs/security/keycloak-integration.md okur â†’ Keycloak'Ä± kurar
3. docs/security/operation-claims-guide.md okur â†’ Claim yapÄ±sÄ±nÄ± anlar
4. Yeni endpoint ekler â†’ @PreAuthorize ile korur
5. docs/security/operation-claims-guide.md gÃ¼nceller â†’ Yeni claim'i dokÃ¼mante eder
```

âœ… **BakÄ±m KolaylÄ±ÄŸÄ±:**
- Keycloak versiyonu gÃ¼ncellendiÄŸinde â†’ Tek dosya deÄŸiÅŸir
- Yeni claim eklendiÄŸinde â†’ DokÃ¼mantasyon rehberi var
- GÃ¼venlik bug'Ä± â†’ Ä°lgili dosyalarda hÄ±zlÄ±ca bulunur

âœ… **Consistency:**
- TÃ¼m gÃ¼venlik kurallarÄ± tek bir kaynakta (AGENTS.md)
- Mimari kararlar DECISIONS.md'de
- Implementation detaylarÄ± docs/security/'de

---

## ğŸ¯ ONAY BEKLÄ°YORUM

Bu plan uygun mu? Onaylarsan:

1. âœ… 5 yeni dosya oluÅŸturacaÄŸÄ±m (security klasÃ¶rÃ¼ altÄ±nda)
2. âœ… 3 mevcut dosya gÃ¼ncelleyeceÄŸim (AGENTS.md, DECISIONS.md, OpenAPI)
3. âœ… TÃ¼m deÄŸiÅŸiklikleri tek seferde (multi_replace) yapacaÄŸÄ±m
4. âœ… Markdown formatÄ±nÄ± dÃ¼zgÃ¼n tutacaÄŸÄ±m
5. âœ… Gelecek entegrasyonlar iÃ§in referans olacak ÅŸekilde yazacaÄŸÄ±m

**DeÄŸiÅŸiklik yapmamÄ± onaylÄ±yor musun?** ğŸš€

User: OnaylÄ±yorum.

GitHub Copilot: MÃ¼kemmel! Åimdi tÃ¼m dosyalarÄ± oluÅŸturup gÃ¼ncelleyeceÄŸim. 

Read [](file:///c%3A/Users/PC1/Desktop/Projects/Education/Java/turkcell-ai-2/AGENTS.md#1-1), lines 1 to 250

Read [](file:///c%3A/Users/PC1/Desktop/Projects/Education/Java/turkcell-ai-2/DECISIONS.md#1-1), lines 1 to 100

Read [](file:///c%3A/Users/PC1/Desktop/Projects/Education/Java/turkcell-ai-2/docs/openapi/order-service.yaml#1-1), lines 1 to 100

Read [](file:///c%3A/Users/PC1/Desktop/Projects/Education/Java/turkcell-ai-2/docs/openapi/inventory-service.yaml#1-1), lines 1 to 100

Åimdi dosyalarÄ± oluÅŸturup gÃ¼ncelleyeceÄŸim: 

Created [](file:///c%3A/Users/PC1/Desktop/Projects/Education/Java/turkcell-ai-2/docs/security/keycloak-integration.md)

Created [](file:///c%3A/Users/PC1/Desktop/Projects/Education/Java/turkcell-ai-2/docs/security/operation-claims-guide.md)

Created [](file:///c%3A/Users/PC1/Desktop/Projects/Education/Java/turkcell-ai-2/docs/security/jwt-token-structure.md)

Created [](file:///c%3A/Users/PC1/Desktop/Projects/Education/Java/turkcell-ai-2/docs/security/security-testing-guide.md)

Created [](file:///c%3A/Users/PC1/Desktop/Projects/Education/Java/turkcell-ai-2/docs/architecture/security-architecture.md)

Åimdi mevcut dosyalarÄ± gÃ¼ncelleyeceÄŸim: 

Read [](file:///c%3A/Users/PC1/Desktop/Projects/Education/Java/turkcell-ai-2/AGENTS.md#250-250), lines 250 to 258

Read [](file:///c%3A/Users/PC1/Desktop/Projects/Education/Java/turkcell-ai-2/DECISIONS.md)

Using "Replace String in File"


```

```


Using "Replace String in File"


```

```


Created [](file:///c%3A/Users/PC1/Desktop/Projects/Education/Java/turkcell-ai-2/DECISIONS.md)

Read [](file:///c%3A/Users/PC1/Desktop/Projects/Education/Java/turkcell-ai-2/DECISIONS.md#50-50), lines 50 to 250

Read [](file:///c%3A/Users/PC1/Desktop/Projects/Education/Java/turkcell-ai-2/DECISIONS.md#260-260), lines 260 to 288

Using "Replace String in File"


```

```
Åimdi OpenAPI dosyalarÄ±nÄ± gÃ¼ncelleyeceÄŸim: 

Read [](file:///c%3A/Users/PC1/Desktop/Projects/Education/Java/turkcell-ai-2/docs/openapi/order-service.yaml#400-400), lines 400 to 473

Read [](file:///c%3A/Users/PC1/Desktop/Projects/Education/Java/turkcell-ai-2/docs/openapi/inventory-service.yaml#500-500), lines 500 to 580

Using "Replace String in File"


```

```


Using "Replace String in File"


```

```
MÃ¼kemmel! ğŸ‰ TÃ¼m dosyalar baÅŸarÄ±yla oluÅŸturuldu ve gÃ¼ncellendi. Ä°ÅŸte yapÄ±lanlarÄ±n Ã¶zeti:

---

## âœ… TAMAMLANAN DOKÃœMANTASYON

### ğŸ“ Yeni OluÅŸturulan Dosyalar (5 adet)

1. **keycloak-integration.md** âœ…
   - Keycloak 26.5.1 kurulum rehberi
   - Docker Compose yapÄ±landÄ±rmasÄ±
   - Realm, client, user kurulumu adÄ±m adÄ±m
   - Test senaryolarÄ±
   - Troubleshooting

2. **operation-claims-guide.md** âœ…
   - Operation-based claims felsefesi
   - TÃ¼m claims listesi (order.*, inventory.*)
   - Composite roles (Customer, Admin, InventoryManager, OrderManager)
   - Permission matrix tablosu
   - Yeni claim ekleme prosedÃ¼rÃ¼

3. **jwt-token-structure.md** âœ…
   - JWT token anatomisi
   - Standard ve custom claims
   - Token lifecycle (expiration, refresh)
   - Spring Boot'ta claim extraction
   - Debugging tips

4. **security-testing-guide.md** âœ…
   - Token alma testleri
   - Authorization test senaryolarÄ±
   - Integration test Ã¶rnekleri
   - Test matrix (endpoint Ã— role)
   - Postman collection yapÄ±sÄ±

5. **security-architecture.md** âœ…
   - ADR-005 formatÄ±nda mimari karar
   - Context, decision, consequences
   - Alternatif Ã§Ã¶zÃ¼mlerin deÄŸerlendirmesi
   - Implementation plan
   - Security considerations

---

### ğŸ“ GÃ¼ncellenen Dosyalar (3 adet)

6. **AGENTS.md** âœ…
   - **Section 7** eklendi: "SECURITY & AUTHENTICATION"
   - Keycloak zorunluluÄŸu
   - Operation claims kurallarÄ±
   - Token propagation
   - SecurityConfig Ã¶rnekleri
   - JwtClaimsConverter implementation
   - Yeni claim ekleme prosedÃ¼rÃ¼

7. **DECISIONS.md** âœ…
   - **ADR-009** eklendi: "Keycloak with Operation-Based Claims"
   - Tarih gÃ¼ncellendi (2026-01-22)
   - Context, decision, alternatives documented
   - TÃ¼m dokÃ¼manlara cross-reference

8. **order-service.yaml** âœ…
   - `securitySchemes` bÃ¶lÃ¼mÃ¼ eklendi
   - `keycloak_oauth` flow tanÄ±mlarÄ±
   - OAuth2 scopes (claims)
   - BearerAuth scheme

9. **inventory-service.yaml** âœ…
   - `securitySchemes` bÃ¶lÃ¼mÃ¼ eklendi
   - Inventory ve reservation claims
   - OAuth2 flow yapÄ±landÄ±rmasÄ±

---

## ğŸ“š DOKÃœMANTASYON HÄ°YERARÅÄ°SÄ°

```
docs/
â”œâ”€â”€ security/                              [YENÄ° KLASÃ–R]
â”‚   â”œâ”€â”€ keycloak-integration.md           [Kurulum rehberi]
â”‚   â”œâ”€â”€ operation-claims-guide.md         [Claims referansÄ±]
â”‚   â”œâ”€â”€ jwt-token-structure.md            [Token anatomisi]
â”‚   â””â”€â”€ security-testing-guide.md         [Test rehberi]
â”‚
â”œâ”€â”€ architecture/
â”‚   â”œâ”€â”€ optimistic-locking-guidelines.md  [Mevcut]
â”‚   â””â”€â”€ security-architecture.md          [YENÄ° - ADR-005]
â”‚
â”œâ”€â”€ openapi/
â”‚   â”œâ”€â”€ order-service.yaml                [GÃœNCELLENDÄ°]
â”‚   â””â”€â”€ inventory-service.yaml            [GÃœNCELLENDÄ°]
â”‚
AGENTS.md                                  [GÃœNCELLENDÄ° - Section 7]
DECISIONS.md                               [GÃœNCELLENDÄ° - ADR-009]
```

---

## ğŸ¯ KULLANIM SENARYOLARI

### Senaryo 1: Yeni Developer/AI Agent
```
1. AGENTS.md okur â†’ Section 7'de gÃ¼venlik kurallarÄ±nÄ± gÃ¶rÃ¼r
2. docs/security/keycloak-integration.md okur â†’ Keycloak'Ä± kurar
3. docs/security/operation-claims-guide.md okur â†’ Claim yapÄ±sÄ±nÄ± anlar
4. Backend servislere SecurityConfig ekler
5. Controller'lara @PreAuthorize annotations ekler
6. docs/security/security-testing-guide.md'ye gÃ¶re test eder
```

### Senaryo 2: Yeni Endpoint Ekleme
```
1. Endpoint iÃ§in gerekli claim'i belirler (Ã¶rn: product.create)
2. Keycloak admin panel'den client role oluÅŸturur
3. Composite role'lere assign eder
4. Controller'da @PreAuthorize("hasAuthority('product.create')") ekler
5. docs/security/operation-claims-guide.md gÃ¼nceller
6. OpenAPI spec'e security requirement ekler
7. Test yazar
```

### Senaryo 3: Keycloak Versiyonu GÃ¼ncelleme
```
1. docs/security/keycloak-integration.md aÃ§ar
2. Docker Compose'daki version tag'ini deÄŸiÅŸtirir
3. Breaking changes varsa dokÃ¼manÄ± gÃ¼nceller
4. Test eder
```

---

## ğŸ”— CROSS-REFERENCES (Otomatik Navigasyon)

TÃ¼m dosyalar birbirine baÄŸlÄ±:

- **AGENTS.md Section 7** â†’ 5 security dokÃ¼manÄ±na link
- **DECISIONS.md ADR-009** â†’ 5 security dokÃ¼manÄ±na + AGENTS.md'ye link
- **security-architecture.md** â†’ TÃ¼m diÄŸer security dokÃ¼manlarÄ±na link
- **Her security dokÃ¼manÄ±** â†’ DiÄŸer ilgili dokÃ¼manlara link

---

## âœ¨ SONUÃ‡

ArtÄ±k projenizde **production-ready** bir gÃ¼venlik dokÃ¼mantasyonu var:

âœ… Keycloak entegrasyonu adÄ±m adÄ±m anlatÄ±lÄ±yor  
âœ… Operation-based claims yapÄ±sÄ± detaylÄ± dokÃ¼mante edilmiÅŸ  
âœ… JWT token yapÄ±sÄ± ve debug rehberi mevcut  
âœ… Test senaryolarÄ± ve best practices belgelenmiÅŸ  
âœ… Mimari kararlar ADR formatÄ±nda kayÄ±tlÄ±  
âœ… AGENTS.md'de AI agent'lar iÃ§in kurallar tanÄ±mlÄ±  
âœ… OpenAPI spec'ler security-aware  

**Gelecekte herhangi bir deÄŸiÅŸiklik olduÄŸunda**, ilgili dokÃ¼manÄ± gÃ¼ncellemek yeterli olacak. TÃ¼m bilgi merkezi ve ulaÅŸÄ±labilir! ğŸš€

Made changes.

User: Benim prompt kalÄ±bÄ±mÄ± inceleyerek bu kalÄ±ba uygun, bu oluÅŸturduÄŸumuz dÃ¶kÃ¼manÄ± takip ederek implementasyonu yapacak promptu bana ver.

GitHub Copilot: Ä°ÅŸte mevcut prompt kalÄ±bÄ±nÄ±za uygun, Keycloak entegrasyonu implementation promptu:

---

```markdown
# KEYCLOAK ENTEGRASYON Ä°MPLEMENTASYONU

Projeye Keycloak 26.5.1 gÃ¼venlik entegrasyonunu eklemeni istiyorum.

## BÄ°LGÄ°LER

- **AGENTS.md Section 7**: Security & Authentication kurallarÄ±
- **docs/security/keycloak-integration.md**: Kurulum ve yapÄ±landÄ±rma rehberi
- **docs/security/operation-claims-guide.md**: Operation-based claims referansÄ±
- **docs/architecture/security-architecture.md**: Mimari kararlar (ADR-005)

## GEREKSÄ°NÄ°MLER

### 1. Gateway Service Security

**Servis**: gateway-service (Port: 8080)

**YapÄ±lacaklar**:
- [ ] `pom.xml`: OAuth2 Client ve Resource Server dependencies ekle
- [ ] `application.yml`: Keycloak issuer-uri, client credentials yapÄ±landÄ±r
- [ ] `SecurityConfig.java`: WebFlux SecurityFilterChain implement et
- [ ] Gateway routes'a `TokenRelay=` filter ekle

**BaÄŸÄ±mlÄ±lÄ±klar (pom.xml'e eklenecek)**:
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-client</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-oauth2-jose</artifactId>
</dependency>
```

**application.yml yapÄ±landÄ±rmasÄ±**:
- `spring.security.oauth2.client` bÃ¶lÃ¼mÃ¼ ekle
- `spring.security.oauth2.resourceserver.jwt` bÃ¶lÃ¼mÃ¼ ekle
- Client secret environment variable olarak kullan: `${KEYCLOAK_CLIENT_SECRET:your-secret-here}`

**SecurityConfig kurallarÄ±**:
- `@EnableWebFluxSecurity` kullan (reactive)
- CSRF disable
- Actuator endpoints permitAll
- OAuth2 login page: `/oauth2/authorization/keycloak`
- JWT validation aktif

---

### 2. Order Service Security

**Servis**: order-service (Port: 8081)

**YapÄ±lacaklar**:
- [ ] pom.xml: Spring Security + OAuth2 Resource Server dependencies ekle
- [ ] application.yml: JWT issuer-uri ve jwk-set-uri yapÄ±landÄ±r
- [ ] `SecurityConfig.java`: SecurityFilterChain + Method Security
- [ ] `JwtClaimsConverter.java`: Custom JWT claims converter implement et
- [ ] OrderController.java: Her method'a `@PreAuthorize` annotation ekle
- [ ] JWT'den user context extraction (userId, username)

**BaÄŸÄ±mlÄ±lÄ±klar (pom.xml'e eklenecek)**:
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
</dependency>
```

**Controller Authorization (docs/security/operation-claims-guide.md'den)**:
- `POST /orders` â†’ `@PreAuthorize("hasAuthority('order.create')")`
- `GET /orders/{id}` â†’ `@PreAuthorize("hasAnyAuthority('order.read.own', 'order.read.all')")`
- `POST /orders/{id}/cancel` â†’ `@PreAuthorize("hasAuthority('order.cancel')")`
- `PATCH /orders/{id}/status` â†’ `@PreAuthorize("hasAuthority('order.status.update')")`

**JwtClaimsConverter gereksinimleri**:
- `order_claims` custom claim'ini extract et
- `List<String>` to `Collection<GrantedAuthority>` dÃ¶nÃ¼ÅŸÃ¼mÃ¼
- `JwtAuthenticationToken` return et

**User Context Extraction**:
```java
@AuthenticationPrincipal Jwt jwt
String userId = jwt.getSubject();
String username = jwt.getClaimAsString("preferred_username");
```

---

### 3. Inventory Service Security

**Servis**: inventory-service (Port: 8082)

**YapÄ±lacaklar**:
- [ ] pom.xml: Spring Security + OAuth2 Resource Server dependencies ekle
- [ ] application.yml: JWT issuer-uri ve jwk-set-uri yapÄ±landÄ±r
- [ ] `SecurityConfig.java`: SecurityFilterChain + Method Security
- [ ] `JwtClaimsConverter.java`: Custom JWT claims converter (inventory_claims)
- [ ] InventoryController.java: Her method'a `@PreAuthorize` annotation ekle

**Controller Authorization (docs/security/operation-claims-guide.md'den)**:
- `GET /inventory/items/{id}` â†’ `@PreAuthorize("hasAuthority('inventory.read')")`
- `POST /inventory/check-availability` â†’ `@PreAuthorize("hasAuthority('inventory.read')")`
- `POST /reservations` â†’ `@PreAuthorize("hasAuthority('reservation.create')")`
- `GET /reservations/{id}` â†’ `@PreAuthorize("hasAuthority('reservation.read')")`
- `POST /reservations/{id}/confirm` â†’ `@PreAuthorize("hasAuthority('reservation.confirm')")`
- `POST /reservations/{id}/cancel` â†’ `@PreAuthorize("hasAuthority('reservation.cancel')")`

**JwtClaimsConverter gereksinimleri**:
- `inventory_claims` custom claim'ini extract et

---

## UYGULAMA KURALLARI (AGENTS.md)

### ZORUNLU Ä°Å AKIÅI:

1. **Plan-First**: DeÄŸiÅŸecek dosyalarÄ± ve nedenlerini listele
2. **File Breakdown**: Her servis iÃ§in hangi dosyalar oluÅŸturulacak/deÄŸiÅŸecek
3. **Ask Questions**: Eksik detay varsa sor (Ã¶rn: Keycloak client secret)
4. **Batch Implementation**: BaÄŸlÄ± dosyalarÄ± grup halinde oluÅŸtur (max 3 dosya/batch)
5. **No Inventing**: AGENTS.md Section 7'yi takip et, kendi kuralÄ±nÄ± ekleme

### CODING STANDARDS:

- **Simplicity**: En basit Ã§alÄ±ÅŸan Ã§Ã¶zÃ¼mÃ¼ tercih et
- **No Over-Engineering**: Gereksiz pattern ekleme
- **SessionCreationPolicy.STATELESS**: CSRF disable
- **Environment Variables**: Client secret'Ä± hardcode etme
- **Hexagonal Architecture**: Security config'i `config/` package'da

### EXAMPLES (AGENTS.md Section 7):

SecurityConfig Ã¶rneÄŸi AGENTS.md'de var, ona uy.
JwtClaimsConverter Ã¶rneÄŸi AGENTS.md'de var, ona uy.
Controller authorization Ã¶rneÄŸi AGENTS.md'de var, ona uy.

---

## EXPECTED OUTPUT

### Phase 1: File Breakdown ve Plan
```
GATEWAY SERVICE:
- pom.xml (gÃ¼ncelle - 3 dependency ekle)
- application.yml (gÃ¼ncelle - security section ekle)
- SecurityConfig.java (yeni - config package)

ORDER SERVICE:
- pom.xml (gÃ¼ncelle - 2 dependency ekle)
- application.yml (gÃ¼ncelle - jwt issuer-uri ekle)
- SecurityConfig.java (yeni - config package)
- JwtClaimsConverter.java (yeni - config package)
- OrderController.java (gÃ¼ncelle - @PreAuthorize ekle)

INVENTORY SERVICE:
- (Order service ile aynÄ± yapÄ±)
```

### Phase 2: Implementation (Batch 1 - Gateway)
- Gateway pom.xml + application.yml + SecurityConfig.java

### Phase 3: Implementation (Batch 2 - Order Service)
- Order pom.xml + application.yml + SecurityConfig.java + JwtClaimsConverter.java

### Phase 4: Implementation (Batch 3 - Order Controller)
- OrderController.java (her method'a @PreAuthorize + JWT extraction)

### Phase 5: Implementation (Batch 4 - Inventory Service)
- (Order service pattern'ini tekrarla)

---

## SORULAR (Eksikse Sor)

1. Keycloak client secret nedir? (gateway-client iÃ§in)
2. Order service client secret nedir?
3. Inventory service client secret nedir?
4. Keycloak URL production'da farklÄ± mÄ±? (ÅŸimdilik localhost:8180 kullan)
5. Test kullanÄ±cÄ±larÄ± oluÅŸturulmuÅŸ mu? (customer1, admin, inventory_manager)

---

## SUCCESS CRITERIA

- [ ] Gateway Ã¼zerinden tÃ¼m istekler JWT token gerektirir
- [ ] Token olmadan 401 Unauthorized dÃ¶nÃ¼yor
- [ ] YanlÄ±ÅŸ claim ile 403 Forbidden dÃ¶nÃ¼yor
- [ ] Customer sadece kendi sipariÅŸlerini gÃ¶rebiliyor
- [ ] Admin tÃ¼m sipariÅŸleri gÃ¶rebiliyor
- [ ] Actuator endpoints herkese aÃ§Ä±k
- [ ] Token JWT.io'da decode edilebiliyor ve claims gÃ¶rÃ¼nÃ¼yor
- [ ] Spring Security logs'ta authorization success/failure gÃ¶rÃ¼nÃ¼yor

---

## REFERENCES

- AGENTS.md Section 7 (ZORUNLU)
- keycloak-integration.md
- operation-claims-guide.md
- security-architecture.md

---

**NOT**: Keycloak'Ä±n Ã§alÄ±ÅŸtÄ±ÄŸÄ±ndan emin ol (docker-compose up -d). Ä°lk Ã¶nce plan ver, sonra batch batch implement et.
```

---

Bu prompt:
âœ… Mevcut prompt kalÄ±bÄ±nÄ±za uygun (Plan-first, file breakdown, ask questions)  
âœ… AGENTS.md Section 7 kurallarÄ±nÄ± takip ediyor  
âœ… OluÅŸturduÄŸumuz dÃ¶kÃ¼manlarÄ± referans alÄ±yor  
âœ… Batch implementation stratejisi var  
âœ… Success criteria tanÄ±mlÄ±  
âœ… Hexagonal Architecture prensiplerine uygun  

Bu promptu kullanarak implementation yapabilirsiniz! ğŸš€---

Bu prompt:
âœ… Mevcut prompt kalÄ±bÄ±nÄ±za uygun (Plan-first, file breakdown, ask questions)  
âœ… AGENTS.md Section 7 kurallarÄ±nÄ± takip ediyor  
âœ… OluÅŸturduÄŸumuz dÃ¶kÃ¼manlarÄ± referans alÄ±yor  
âœ… Batch implementation stratejisi var  
âœ… Success criteria tanÄ±mlÄ±  
âœ… Hexagonal Architecture prensiplerine uygun  

Bu promptu kullanarak implementation yapabilirsiniz! ğŸš€

User: `standard.md` dosyasÄ±ndaki prompt kalÄ±bÄ±nÄ± kullan, oluÅŸturduÄŸun promptu `docs/prompt/keycloak-entegration.md` olarak kaydet.

GitHub Copilot: Created [](file:///c%3A/Users/PC1/Desktop/Projects/Education/Java/turkcell-ai-2/docs/prompt/keycloak-entegration.md)

Prompt dosyasÄ± keycloak-entegration.md olarak oluÅŸturuldu.

R-C-T-C-O-E formatÄ±nda hazÄ±rlandÄ±:

- **ROLE**: Senior Spring Security Engineer rolÃ¼ tanÄ±mlandÄ±
- **CONTEXT**: Neden Keycloak + operation-based claims kullanÄ±yoruz aÃ§Ä±klandÄ±
- **TASK**: 5 fazda 22 atomik gÃ¶rev (Infrastructure â†’ Gateway â†’ Order â†’ Inventory â†’ Testing)
- **CONSTRAINTS**: 10 "NEVER DO" kuralÄ± + AGENTS.md uyum gereksinimleri
- **OUTPUT**: 
  - 16 dosya breakdown (CREATE/MODIFY)
  - 5 implementation batch
  - Role-Endpoint-Claim matrisi
  - Configuration template'leri
  - Success criteria checklist
- **EXAMPLES**: 8 Ã¶rnek (token acquisition, API calls, ownership checks, test code)

**Bonus**: 10 verification question eklendi - implementasyona baÅŸlamadan Ã¶nce cevaplanmasÄ± gereken sorular.

Bu promptu baÅŸka bir AI agent'a (veya geliÅŸtiriciye) verdiÄŸinizde, AGENTS.md kurallarÄ±na uygun ÅŸekilde implementation yapabilecek.

Made changes.